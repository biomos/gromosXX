/*
 * This file is part of GROMOS.
 * 
 * Copyright (c) 2011, 2012, 2016, 2018, 2021, 2023 Biomos b.v.
 * See <https://www.gromos.net> for details.
 * 
 * GROMOS is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 2 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 */

/**
 * @file explode.cc
 * Put molecules at large intermolecular distances
 */

/**
 * @page programs Program Documentation
 *
 * @anchor explode
 * @section explode Put molecules at large intermolecular distances
 * @author @ref co
 * @date 8-6-07
 *
 * Program explode takes a box with nsm molecules and puts them on a grid with
 * distance dist between the grid points. This tool is useful in case a vacuum
 * simulation has to be performed by simulating nsm molecules at a 
 * large intermolecular distance. The input topology and coordinate files must 
 * contain nms molecules or more. If there are less molecules than grid positions
 * a message is printed to inform the user.
 * As input coordinates one can for instance take a liquid box generated by
 * program @ref build_box (see section V-2.9).
 *
 * <b>arguments:</b>
 * <table border=0 cellpadding=0>
 * <tr><td> \@topo</td><td>&lt;molecular topology file&gt; </td></tr>
 * <tr><td> \@pos</td><td>&lt;coordinates for the molecules&gt; </td></tr>
 * <tr><td> \@nsm</td><td>&lt;number of solute molecules </td></tr>
 * <tr><td> \@dist</td><td>&lt;distance to put between molecules&gt; </td></tr>
 * </table>
 *
 *
 * Example:
 * @verbatim
  explode
    @topo   dmso.top
    @pos    dmso.g96
    @nsm    1000
    @dist   50
 @endverbatim
 *
 * <hr>
 */

#include <cassert>
#include <cstdlib>
#include <string>
#include <sstream>
#include <cmath>
#include <iostream>

#include "../src/args/Arguments.h"
#include "../src/args/GatherParser.h"
#include "../src/fit/PositionUtils.h"
#include "../src/gio/InG96.h"
#include "../src/gio/OutG96S.h"
#include "../src/gcore/System.h"
#include "../src/gcore/Molecule.h"
#include "../src/gcore/Box.h"
#include "../src/gio/InTopology.h"
#include "../src/gmath/Vec.h"
#include "../src/bound/RectBox.h"
#include "../src/gromos/Exception.h"

using namespace std;
using namespace gcore;
using namespace gio;
using namespace fit;
using namespace gmath;
using namespace bound;
using namespace args;


int main(int argc, char **argv){

  Argument_List knowns; 
  knowns << "topo" << "pos" << "nsm" << "dist";  

  string usage = "# " + string(argv[0]);
  usage += "\n\t@topo <molecular topology file>\n";
  usage += "\t@pos  <coordinates for the molecules>\n";
  usage += "\t@nsm  <number of solute molecules\n";
  usage += "\t@dist <distance to put between molecules>\n";
  

  try{
    Arguments args(argc, argv, knowns, usage);
    // set some values
    int nsm = args.getValue<int>("nsm");
    double box3 = args.getValue<double>("dist");
    
    int nsm3 = ceil(pow(double(nsm),1.0/3.0));
    double box=nsm3*box3;
    Vec box32(box3/2.0, box3/2.0, box3/2.0);

    // read topology
    args.check("topo",1);
    InTopology it(args["topo"]);
    System smol(it.system());

    System refSys(it.system());

    //for(int i=1;i<nsm;i++) smol.addMolecule(it.system().mol(0));
    
    
    // read singe atom coordinates...
    InG96 ic;
    args.check("pos",1);
    ic.open(args["pos"]);
    ic >> smol;
    ic.close();

    // new system
    System sys;
    Boundary *pbc;
    pbc=new RectBox(&smol);
    // parse gather method
    Boundary::MemPtr gathmethod = args::GatherParser::parse(sys,refSys,args);
    //gather
    (*pbc.*gathmethod)();
    
    // set the size and shape of the new (cubic) box
    sys.box().setNtb(Box::rectangular);
    sys.box().K()[0] = box;
    sys.box().L()[1] = box;
    sys.box().M()[2] = box;

    // add solvent to sys
    sys.addSolvent(smol.sol(0));

    int count=0;

    for(int i=0;i<nsm3;i++){
      for(int j=0;j<nsm3;j++){
	for(int k=0;k<nsm3;k++){
          // if there are more spaces on the grid than moleciles, leave it empty
          if (count >= nsm) {
            count++;
            continue;
          }
	  Vec shift(i*box3,j*box3, k*box3);    
          Molecule onemol=smol.mol(count);
          System sonemol;
          sonemol.addMolecule(onemol);
	  sonemol.addSolvent(smol.sol(0));
          Vec rc=PositionUtils::com(sonemol)-box32;
          PositionUtils::translate(&sonemol, -rc+shift);
	  sys.addMolecule(sonemol.mol(0));
          count++;
	}
      }
    }
    // write a NOTE message on the screen if there are empty space on the grid
    if(count > nsm) {
      stringstream msg;
      msg << "NOTE: " << count - nsm << " empty positions on the grid ("
              << nsm3 * nsm3 * nsm3 << " grid points) since only "
              << nsm << " molecules positioned";
      cerr << msg.str() << endl;
    }
    // Print the new set to cout
    OutG96S oc;
    ostringstream os;
    os << "Explode : " << nsm << " molecules put at intermolecular distance ";
    os << box3 << " nm\n";
    os << "Taken from: " <<args["pos"];
    
    oc.open(cout);
    oc.writeTitle(string(os.str()));
    oc << sys;
  }
  catch (const gromos::Exception &e){
    cerr << e.what() << endl;
    exit(1);
  }
  return 0;
}




