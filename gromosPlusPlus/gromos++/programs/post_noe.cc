/*
 * This file is part of GROMOS.
 * 
 * Copyright (c) 2011, 2012, 2016, 2018, 2021, 2023 Biomos b.v.
 * See <https://www.gromos.net> for details.
 * 
 * GROMOS is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 2 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 */

/**
 * @file post_noe.cc
 * Re-analyses the output of program noe
 */

/**
 * @page programs Program Documentation
 *
 * @anchor post_noe
 * @section post_noe re-analyses the output of program noe
 * @author @ref co
 * @date 16.8.2006
 *
 * Program post_noe allows the user to re-analyse the data that was generated by
 * program noe. It reads in the NOE specification file, and the filter-file,
 * which were generated by program @ref prep_noe "prep_noe", as well as the 
 * output of program @ref noe "noe". 
 *
 * In cases where a stereospecific hydrogen from a CH2-group, without an
 * explicit assignment was given in the library file of program @ref prep_noe 
 * (type 4 without subtype), the NOE-distance according to both virtual atoms
 * will have been calculated. Program post_noe can be used to select from these
 * distance the protons that shows either the largest or the smallest violation
 * with the experimental data. Additionally, the user can choose to disregard
 * specific NOE's either by specifying a 0 in the filter-field of the 
 * filter-file that was generated by @ref prep_noe, or by giving a cutoff
 * distance.
 *
 * The user may want to regenerate the filter file using a different kind of
 * pseudo-atom and multiplicity correction by running the @ref prep_noe program
 * a second time. When using post_noe, the reference distances can then be read
 * from this filter-file allowing for a quick assessment of the effect of the
 * corrections. Furthermore, the user can tell post_noe to change the
 * exponential in the averaging method. 
 *
 * <b>arguments:</b>
 * <table border=0 cellpadding=0>
 * <tr><td> \@topo</td><td>&lt;molecular topology file&gt; </td></tr>
 * <tr><td> \@noe</td><td>&lt;NOE specification file&gt; </td></tr>
 * <tr><td> \@noeoutput</td><td>&lt;output of noe-program&gt; </td></tr>
 * <tr><td> \@filter</td><td>&lt;NOE filter file&gt; </td></tr>
 * <tr><td> \@averaging</td><td>&lt;1 / 3 / 6&gt; </td></tr>
 * <tr><td> [\@distance</td><td>&lt;additional filter distance&gt;] </td></tr>
 * <tr><td> [\@ref</td><td>&lt;noeoutput / filter&gt;] </td></tr>
 * <tr><td> [\@minmax</td><td>&lt;min / max&gt; </td></tr>
 * <tr><td> [\@distribution</td><td>&lt;binsize&gt; </td></tr>
 * </table>
 *
 *
 * Example:
 * @verbatim
  post_noe
    @topo         ex.top
    @noe          noe.spec
    @noeoutput    noe.out
    @filter       noe.filter
    @averaging    3
    @distance     8
    @ref          filter
    @minmax       min
    @distribution 0.1
 @endverbatim
 *
 * <hr>
 */
// noeprep.cc; 

#include <cassert>
#include <string>
#include <vector>
#include <iomanip>
#include <iostream>
#include <cmath>
#include <sstream>
#include <limits>

#include "../src/args/Arguments.h"
#include "../src/gio/Ginstream.h"
#include "../src/gio/InG96.h"
#include "../src/gcore/System.h"
#include "../src/gio/InTopology.h"
#include "../src/bound/Boundary.h"
#include "../src/args/BoundaryParser.h"
#include "../src/gmath/Distribution.h"
#include "../src/gcore/AtomTopology.h"
#include "../src/gcore/Molecule.h"
#include "../src/gcore/MoleculeTopology.h"
#include "../src/utils/VirtualAtom.h"

using namespace std;
using namespace gio;
using namespace gcore;
using namespace args;

class yaNoe
{
 public:
  yaNoe();
  yaNoe(System const &sys, int at1, int at2, double r)
    {
      //determine molecule
      int offset;
      at1--; at2--;

      for(offset=0, mol1=0; at1>=sys.mol(mol1).numAtoms()+offset; mol1++)
        offset += sys.mol(mol1).numAtoms();
      atom1=at1-offset;
      for(offset=0, mol2=0; at2>=sys.mol(mol2).numAtoms()+offset; mol2++)
        offset += sys.mol(mol2).numAtoms();
      atom2=at2-offset;
      
      r0=r;
    }
  int atom1;
  int atom2;
  int mol1;
  int mol2;
  int type;
  vector<int> collaps;
  
  double r0;
  double r_av[3];
  double rmsd[3];
  double ee[3];

  string h_name1;
  string h_name2;
};

void read_NOE_input(System &sys, vector<yaNoe *> &noe, string filename);
void read_NOE_output(System &sys, vector<yaNoe *> &noe, string filename);
void read_NOE_filter(System &sys, vector<yaNoe *> &noe, string filename, 
		     bool read_ref);

int main(int argc,char *argv[]){
  Argument_List knowns;
  knowns << "topo" << "noe" << "noeoutput" << "filter" << "distance" 
         << "averaging" << "ref" << "minmax" << "distribution";

  string usage = "# " + string(argv[0]);
  usage += "\n\t@topo          <topology>\n";
  usage += "\t@noe           <NOE specification file>\n";
  usage += "\t@noeoutput     <output of noe-program>\n";
  usage += "\t@filter        <NOE filter file>\n";
  usage += "\t@averaging     <1 / 3 / 6>\n";
  usage += "\t[@distance     <additional filter distance>]\n";
  usage += "\t[@ref          <noeoutput / filter>]\n";
  usage += "\t[@minmax       <min / max>\n";
  usage += "\t[@distribution <binsize>\n";
  

  // prepare cout for formatted output
  cout.setf(ios::right, ios::adjustfield);
  cout.setf(ios::fixed, ios::floatfield);
  cout.precision(3);
    
  try{
    
    // Getting arguments and checking if everything is known.
    Arguments args(argc,argv,knowns,usage);

    // read topology
    InTopology it(args["topo"]);
    System sys(it.system());

    // where do we want to read the reference lengths from
    bool ref_from_filter=false;
    if(args.count("ref")>0){
      if(args["ref"] == "filter") ref_from_filter=true;
      else if(args["ref"] != "noeoutput"){
	throw gromos::Exception("post_noe", "Illegal value for 'ref' "
				"allowed are noeoutput or filter");
      }
    }
    
    // get a possible additional distance filter
    double cutoff=-1.0;
    bool do_distance_filter=false;
    if(args.count("distance")>0){
      cutoff = atof(args["distance"].c_str());
      do_distance_filter=true;
    }
    
    // which lengths do we want to use for the averaging
    int av_index=args.getValue<int>("averaging") / 3;
    if (av_index < 0 || av_index > 2)
      throw gromos::Exception(argv[0], "Averaging has to be 1, 3 or 6.");

    // do we want to minimise or maximise the violations upon collaps
    int minmax=1;
    if(args.count("minmax")>0){
      if(args["minmax"]=="max") minmax=-1;
      else if(args["minmax"]!="min")	
	throw gromos::Exception("post_noe", "Illegal value for 'minmax' "
				"allowed are min or max");
    }
    
    // in noe all noes will be stored.
    vector<yaNoe*> noe;

    // read the NOE input file
    read_NOE_input(sys, noe, args["noe"]);

    // Read in the NOE output
    read_NOE_output(sys, noe, args["noeoutput"]);
    
    // read in filter file
    read_NOE_filter(sys, noe, args["filter"], ref_from_filter);
    
    // =======
    // Everything read, let's start the program
    // =======

    // let's keep a list of noe's to keep
    vector<yaNoe *> keep;
    int num_distance_filtered=0;
    int num_user_filtered = 0;
    int num_collapsed =0;
    
    for(unsigned int i=0; i<noe.size(); i++){
      
      // first test: filter action should not be set to 0
      if(noe[i]->type > 0){
	
	// second test: maybe it is filtered based on the r0
	if(!do_distance_filter || noe[i]->r0 <= cutoff){
	  
	  // third test: should it be collapsed
	  if(noe[i]->type > 1){
	    
	    //calculate the smallest noe-violation for all relevant noe's
	    double mindist=minmax*(noe[i]->r_av[av_index] - noe[i]->r0);
	    unsigned int minnoe=i;
	    for(int j=0; j<noe[i]->type-1; j++){
	      
	      if(noe[noe[i]->collaps[j]]->type!=0){
		
		double v=minmax*(noe[noe[i]->collaps[j]]->r_av[av_index] - 
				 noe[noe[i]->collaps[j]]->r0);
		if(v<mindist){
		  mindist=v;
		  minnoe=noe[i]->collaps[j];
		}
		// flag it so that it will not be considered anymore
		noe[noe[i]->collaps[j]]->type=-1;
	      }
	    }
	    
	    keep.push_back(noe[minnoe]);
	    num_collapsed+=noe[i]->type-1;
	  }
	  else{
	    keep.push_back(noe[i]);
	  }
	}
	else num_distance_filtered++;
      }
      else if(noe[i]->type==0) num_user_filtered++;
      
    }

    // write out and average the noe's we have left and make a distribution
    bool do_dist=false;
    double dist_size=0.0;
    if(args.count("distribution")>0){
      dist_size=atof(args["distribution"].c_str());
      do_dist=true;
    }
    

    // cout << "we have now " << keep.size() << " NOE's left" << endl;
    // get the averages and minimum and maximum violation
    double s_r0=0, s_viol=0, ss_viol=0, min_viol=0, max_viol=0;
    double viol;
    int num_viol=0;
    
    for(unsigned int i=0; i< keep.size(); i++){
      s_r0 += keep[i]->r0;
      viol = keep[i]->r_av[av_index] - keep[i]->r0;
      if(viol>0){
	num_viol++;
	s_viol+= viol;
	ss_viol += viol * viol;
      }
      if(viol < min_viol) min_viol=viol;
      if(viol > max_viol) max_viol=viol;
    }
    int bla=100;
    if(do_dist) {
      min_viol=(rint(min_viol/dist_size)-1)*dist_size;
      max_viol=(rint(max_viol/dist_size)+1)*dist_size;
      bla=int(rint((max_viol-min_viol)/dist_size));
    }
    
    // add roughly one more bin, so that you also get the highest itself
    // (a Distribution goes from min <= value < max)
    gmath::Distribution dist(min_viol, max_viol, bla);

    cout << "TITLE\n"
	 << "Postprocessing NOE data using:\n"
	 << "\tNOE input  : " << args["noe"] << endl
	 << "\tNOE output : " << args["noeoutput"] << endl
	 << "\tNOE filter : " << args["filter"] << endl;

    cout << "\nUpper bounds have been taken from ";
    if(ref_from_filter) cout << "NOE filter file\n";
    else cout << "NOE input file\n";
    
    cout << "\n" << setw(5) << noe.size() << " initial NOE's to analyse\n";
    
    if(num_user_filtered)
      cout << "\n" << setw(5) << num_user_filtered 
	   << " NOE's have been removed "
	   << "by direct filtering according to user input\n";
    if(num_distance_filtered)
      cout << "\n" << setw(5) << num_distance_filtered 
	   << " NOE's have been removed "
	   << "according to distance criterion (r0 > " << cutoff << ")\n";
    if(num_collapsed){
      cout << "\n" << setw(5) << num_collapsed 
	   << " NOE's have been removed after "
	   << "assignment of stereospecific NOE's\n"
	   << "            assignment was based on ";
      if (minmax==1) cout << "min"; else cout << "max";
      cout << "imum violations\n";
    }
    
    if( num_collapsed+num_user_filtered+num_distance_filtered)
      cout << "\n" << setw(5) << keep.size() << " NOE's left over\n";
    
    cout << "\nEND\n";
    
    int averaging=3;
    if(av_index==0) averaging=1;
    else if(av_index==1) averaging=3;
    else if(av_index==2) averaging=6;

    cout << "AVERAGE NOE VIOLATIONS"
	 << "\n#\n# Average NOE distances calculated as <r^-" << averaging
	 << ">^-1/" << averaging
	 << "\n#\n";
    
    cout << "# noe"
	 << setw(4) << "mol"
	 << setw(10) << "residue"
	 << setw(10) << "atom"
	 << setw(5) << "orig"
	 << setw(8) << "mol"
	 << setw(10) << "residue"
	 << setw(10) << "atom"
	 << setw(5) << "orig"
	 << setw(12) << "r0"
	 << setw(8) << "r_av"
         << setw(8) << "rmsd"
         << setw(8) << "ee"
	 << setw(8) << "viol" 
	 << endl;
    
    for(unsigned int i=0; i< keep.size(); i++){
      viol = keep[i]->r_av[av_index] - keep[i]->r0;
      
      cout << setw(5) << i+1 
	   << setw(4) << keep[i]->mol1+1
	   << setw(5) << sys.mol(keep[i]->mol1).topology().resNum(keep[i]->atom1)+1
	   << setw(5) << sys.mol(keep[i]->mol1).topology().resName(sys.mol(keep[i]->mol1).topology().resNum(keep[i]->atom1))
	   << setw(5) << keep[i]->atom1+1
	   << setw(5) << sys.mol(keep[i]->mol1).topology().atom(keep[i]->atom1).name()
	   << setw(5) << keep[i]->h_name1
	   << setw(8) << keep[i]->mol2+1
	   << setw(5) << sys.mol(keep[i]->mol2).topology().resNum(keep[i]->atom2)+1
	   << setw(5) << sys.mol(keep[i]->mol2).topology().resName(sys.mol(keep[i]->mol2).topology().resNum(keep[i]->atom2))
	   << setw(5) << keep[i]->atom2+1
	   << setw(5) << sys.mol(keep[i]->mol2).topology().atom(keep[i]->atom2).name()
	   << setw(5) << keep[i]->h_name2
	   << setw(12) << keep[i]->r0
	   << setw(8) << keep[i]->r_av[av_index]
           << setw(8) << keep[i]->rmsd[av_index]
           << setw(8) << keep[i]->ee[av_index]
	   << setw(8) << viol 
	   << endl;
      if(do_dist) dist.add(viol);
    }
    cout << "END\n";
    cout << "VIOLATION AVERAGES\n";
    cout << setw(5) << keep.size() << " NOE's analysed\n"
	 << "      Average r0            " << s_r0 / keep.size() << "\n\n"
	 << setw(5) << num_viol << " violations\n";
    if(num_viol)
      cout << "      Average of violations " << s_viol/keep.size()
	  << "\n      RMS violations        " 
	   << sqrt((ss_viol - s_viol*s_viol/keep.size())/keep.size()) << endl;
    cout << "END\n";
    
    if(do_dist){
      cout << "VIOLATION DISTRIBUTION\n";
      cout << "# "
	   << setw(6) << "viol"
	   << setw(13) << "count"
	   << endl;
      
      dist.write(cout);
      cout << "END" << endl;;
    }
   
  }
  
  catch(gromos::Exception e){
    cerr << e.what() << endl;
    exit(1);
  }
  return 0;
}

void read_NOE_input(System &sys, vector<yaNoe *> &noe, string filename)
{
  // Read in and create the NOE list from the noe input
  Ginstream nf(filename);
  vector<string> buffer;
  nf.getblock(buffer);
  
  if(buffer.size() < 1 || buffer[0]!="NOECALCSPEC")
    throw gromos::Exception("main",
			    "NOE file does not contain an NOECALCSPEC block!");
  if(buffer.size() < 1 || buffer[buffer.size()-1].find("END")!=0)
    throw gromos::Exception("post_noe","NOE file " + nf.name() +
			    " is corrupted. No END in NOECALCSPEC"
			    " block. Got\n"
			    + buffer[buffer.size()-1]);
  int at1,at2,idum;
  double r;
  string sdum;
  istringstream is;
  
  // we don't care about the distances here, so start reading at the 2nd
  for(unsigned int j=2; j< buffer.size()-1; j++){
    is.clear();
    is.str(buffer[j]);
    is >> at1 >> idum >> idum >> idum >> idum >> idum
       >> at2 >> idum >> idum >> idum >> idum >> idum
       >> r;
    
    noe.push_back(new yaNoe(sys, at1, at2, r));
  }
  
  nf.close();
  
}

void read_NOE_output(System &sys, vector<yaNoe *> &noe, string filename)
{
  Ginstream nf(filename);
  vector<string> buffer;
  istringstream is;

  int idum;
  string sdum;
  double r;
  
  nf.getblock(buffer);
  if(buffer.size() < 1 || buffer[0]!="AVERAGE NOE")
    throw gromos::Exception("post_noe", "No AVERAGE NOE block in file "
			    + filename);
  if(buffer.size() < 1 || buffer[buffer.size()-1].find("END")!=0)
      throw gromos::Exception("post_noe","NOE output file " + nf.name() +
			      " is corrupted. No END in AVERAGE NOE"
			      " block. Got\n"
			      + buffer[buffer.size()-1]);
  if(buffer.size()-2!=noe.size()){
    throw gromos::Exception("post_noe","NOE input file and AVERAGE NOE "
			    "block do not have the same number of NOE's\n");
  }


  for(unsigned int i=0; i<noe.size(); i++){
    is.clear();
    is.str(buffer[i+1]);
    is >> idum 
       >> noe[i]->r_av[0] 
       >> noe[i]->r_av[1] 
       >> noe[i]->r_av[2];
    // errors/rmsds can all be nan and we wan't to keep that information!
    if (!(is >> noe[i]->rmsd[0]) && numeric_limits<double>::has_signaling_NaN)
      noe[i]->rmsd[0] = numeric_limits<double>::signaling_NaN();
    if (!(is >> noe[i]->rmsd[1]) && numeric_limits<double>::has_signaling_NaN)
      noe[i]->rmsd[1] = numeric_limits<double>::signaling_NaN();
    if (!(is >> noe[i]->rmsd[2]) && numeric_limits<double>::has_signaling_NaN)
      noe[i]->rmsd[2] = numeric_limits<double>::signaling_NaN();
    if (!(is >> noe[i]->ee[0]) && numeric_limits<double>::has_signaling_NaN)
      noe[i]->ee[0] = numeric_limits<double>::signaling_NaN();
    if (!(is >> noe[i]->ee[1]) && numeric_limits<double>::has_signaling_NaN)
      noe[i]->ee[1] = numeric_limits<double>::signaling_NaN();
    if (!(is >> noe[i]->ee[2]) && numeric_limits<double>::has_signaling_NaN)
      noe[i]->ee[2] = numeric_limits<double>::signaling_NaN();

  }
  buffer.clear();
  nf.getblock(buffer);
  if(buffer.size() < 1 || buffer[0]!="NOE VIOLATIONS")
    throw gromos::Exception("post_noe", "No NOE VIOLATIONS block in file "
			    + filename);
  if(buffer.size() < 1 || buffer[buffer.size()-1].find("END")!=0)
      throw gromos::Exception("post_noe", "NOE output file " + nf.name() +
			      " is corrupted. No END in NOE VIOLATIONS"
			      " block. Got\n"
			      + buffer[buffer.size()-1]);
  if(buffer.size()-2!=noe.size()){
    throw gromos::Exception("post_noe","NOE input file and NOE VIOLATIONS "
			    "block do not have the same number of NOE's\n");
  }
  
  for(unsigned int i=0; i<noe.size(); i++){
    is.clear();
    is.str(buffer[i+1]);
    is >> sdum >> r;
    // NOE VIOLATIONS block stores 3 digits (non-consistently rounded!) after the decimal point: we must allow for +- 2/1000 deviation from noe[i]->r0.
    double rounded_noe, rounded_r;
    rounded_noe = floor(noe[i]->r0 * 1000 ) / 1000.0;  // even though we round both here, we still cannot compare the numbers directly!
    rounded_r = floor(r * 1000 ) / 1000.0;
    
    if(abs(rounded_r - rounded_noe) > 0.002){ // allow +/- 2/1000 deviation. this does not work if directly comparing numbers! e.g. r != rounded_noe
      throw gromos::Exception("post_noe", "NOE distance has changed from NOE"
			      " input to NOE output file in NOE "+sdum);
    }
  }
  nf.close();
    
}

void read_NOE_filter(System &sys, vector<yaNoe *> &noe, string filename, 
		     bool read_ref)
{
  Ginstream nf(filename);
  vector<string> buffer;
  istringstream is;

  nf.getblock(buffer);
  
  if(buffer.size() < 1 ||  buffer[0]!="NOEFILTER"){
    throw gromos::Exception("post_noe", "No NOEFILTER block in file "
			    + filename);
  }
  if(buffer.size() < 1 ||  buffer[buffer.size()-1].find("END")!=0)
    throw gromos::Exception("post_noe", "Filter file " + nf.name() +
			    " is corrupted. No END in NOEFILTER"
			    " block. Got\n"
			    + buffer[buffer.size()-1]);
  if(buffer.size()-2!=noe.size()){
    throw gromos::Exception("post_noe", "NOE input file and NOE filter file "
			    "do not have the same number of NOE's");
  }

  
  for(unsigned int i=0; i<noe.size(); i++){
    int m1, r1, m2, r2, idum;
    string rn1, atn1, rn2, atn2, sdum;
    double r_filt;
    
    is.clear();
    is.str(buffer[i+1]);
    is >> sdum 
       >> m1 >> r1 >> rn1 >> atn1 >> noe[i]->h_name1
       >> m2 >> r2 >> rn2 >> atn2 >> noe[i]->h_name2
       >> r_filt >> noe[i]->type;
    for(int j=0; j<noe[i]->type-1; j++){
      is >> idum;
      noe[i]->collaps.push_back(idum-1);
    }
    // check input
    if(m1 != noe[i]->mol1 +1){
      throw gromos::Exception("post_noe", "NOE filter file does not match "
			      "NOE input file and topology (mol1)"
			      +buffer[i+1]);
    }
    if(m2 != noe[i]->mol2 +1){
      throw gromos::Exception("post_noe", "NOE filter file does not match "
			      "NOE input file and topology (mol2)"
			      +buffer[i+1]);
    }
    //cout << r1 << " " << noe[i]->atom1 << " " << sys.mol(noe[i]->mol1).topology().resNum(noe[i]->atom1) << endl;
    
    if(r1 != sys.mol(noe[i]->mol1).topology().resNum(noe[i]->atom1)+1){
      throw gromos::Exception("post_noe", "NOE filter file does not match "
			      "NOE input file and topology (resNum1)"
			      +buffer[i+1]);
    }
    if(r2 != sys.mol(noe[i]->mol2).topology().resNum(noe[i]->atom2)+1){
      throw gromos::Exception("post_noe", "NOE filter file does not match "
			      "NOE input file and topology (resNum2)"
			      +buffer[i+1]);
    }	
    if(rn1 != sys.mol(noe[i]->mol1).topology().
       resName(sys.mol(noe[i]->mol1).topology().resNum(noe[i]->atom1))){
      throw gromos::Exception("post_noe", "NOE filter file does not match "
			      "NOE input file and topology (resName1)"
			      +buffer[i+1]);
    }
    if (rn2 != sys.mol(noe[i]->mol2).topology().
        resName(sys.mol(noe[i]->mol2).topology().resNum(noe[i]->atom2))) {
      throw gromos::Exception("post_noe", "NOE filter file does not match "
              "NOE input file and topology (resName2)"
              + buffer[i + 1]);
    }
    if(read_ref)
      noe[i]->r0=r_filt;
  }
  nf.close();
  
}

